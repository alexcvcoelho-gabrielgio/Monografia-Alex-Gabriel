\chapter{Resultados}
\label{chap:analiseresultados}
Inicialmente para criação da arquitetura especificada na seção \ref{chap:arquitetura}, criou-se o serviço de \textit{Command}, o qual é a porta de entrada entre a interface de usuário e a arquitetura, este serviço tem a função de receber os dados da interface, validá-los e inserir na fila do Kafka, é através dela que um carro terá a sua sessão criada (\textit{Command Session}), ou informará dados sobre a localização (\textit{Command Track}), ou ainda informações de alerta (\textit{Command Warning}), para isso, como pode ser observado no apêndice \ref{ap:sessioncommand}, se tem as validações para cada um dos modelos de dados, no caso das informações referentes a sessão se tem informações sobre a marca, modelo, placa e proprietário, para o modelo de localização o identificador da sessão, nível de combustível, latitude, longitude e velocidade, para o modelo de alertas o identificador da sessão e o alerta emitido, todos estes dados são manipulados e recebidos no formato \textit{JavaScript Object Notation} (JSON) por questões de velocidade e uso de memória. Ainda no apêndice  \ref{ap:sessioncommand} é apresentado todos os comandos de envio para a fila do Kafka de cada um dos modelos de dados.

Seguindo a arquitetura, tornou-se necessário a configuração da fila de mensagens (Kafka), a qual tem a função de armazenar uma informação por um determinado tempo até que ela seja consumida por algum outro serviço. Para isso utilizou-se imagens Docker vindas de repositórios oficiais, sendo necessário um contêiner Kafka Zookeeper que é o sistema responsável por gerenciar os \textit{brokers} do Kafka, e o Kafka Broker que são os \textit{brokers}, onde ficam armazenados os tópicos, cada um funcionando em um contêiner separado.

O próximo passo que se tem dentro da arquitetura é a criação do micro serviço \textit{Worker}, o qual tem a finalidade de ler dados da fila de mensagens e armazená-las nos bancos de dados, para isso este micro serviço foi criado em Clojure, contendo a conexão com o Kafka, além das conexões com os bancos de dados MongoDB e Datomic, o apêndice \ref{ap:sessionworker} mostra a retirada de dados da fila de mensagens e gravação dos dados nos bancos MongoDB e Datomic de acordo com o tipo de informação contida na mensagem.

Por fim foram configurados os bancos de dados, os quais armazenam os dados vindos dos serviços de \textit{Workers} e os mantém para consultas instantâneas no caso do MongoDB, ou consultas históricas no caso do Datomic. Para os dois bancos de dados utilizou-se de imagens Docker oficiais com a base de dados armazenadas no \textit{host}, para que os dados fiquem disponíveis para todos os contêineres, mesmo quando estes sejam replicados.

Tendo os dados armazenados, para o processo de leitura destes dados criou-se o micro serviço \textit{Command Query} também em Clojure, o qual tem a função de ler os dados inseridos no MongoDB ou no Datomic, sem passar pela fila de mensagens diretamente ele realiza a função de busca de dado desejado diretamente no banco de dados que se deseja, retornando para o usuário que requisitou esta informação a ser exibida no painel do carro.

Todos os micro serviços  utilizados dentro da arquitetura apresentam-se encapsulados dentro de contêineres, estes porém, possuem a base inicial vinda de uma imagem Docker oficial, no caso dos micro serviços utilizou-se a imagem Java com \textit{Java SE Runtime Environment} (JRE) em sua versão 8, sendo assim, as alterações e configurações para o ambiente desejado se fizeram através do Dockerfile, que ao ser construído gera uma nova imagem com as alterações nele contidos, e para criação do contêiner basta especificar que a imagem a ser usada será esta nova imagem.



\section{Testes de Sistema}
\label{sec:testessistema}
Montada a arquitetura especificada na seção \ref{chap:arquitetura}, iniciou-se o processo de inserção de dados nesta estrutura através do conceito de \textit{Mockup}, o qual simula funcionalidades do sistema para que estas possam ser testadas de forma independente, sendo assim, dentro desta arquitetura os objetos \textit{mock} foram os carros e unidades de emergência, os quais tiveram seu comportamento simulado via \textit{software}, a fim de validar o armazenamento e fluxo de dados na arquitetura.

O \textit{Mockup} realizou-se por meio de um micro serviço escrito em Clojure, o qual cria uma quantidade de conexões pré-estabelecidas com o micro serviço \textit{Session Command} e envia dados fictícios sobre localização, nível de combustível e alertas em cada conexão criada, esses dados passam a serem inseridos na fila do Kafka após terem as informações validadas pelo \textit{Session Command}, desta forma o micro serviço \textit{Session Worker} retira da fila e popula os bancos de dados Datomic ou MongoDB

\section{Testes de Aceitação}
\label{sec:testesaceitacao}
Análise dos resultados obtidos e analisar o benefício do usuário utilizador do sistema, analisar se seria aprovado pelo mesmo e pelos agentes sociais.

\section{Discussão de Resultados}
\label{sec:discussãoresultados}
Aqui se apresenta os resultados gerais, estatísticos, apresentando os principais pontos positivos e negativos do trabalho baseados nos dados analisados.